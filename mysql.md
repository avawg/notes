## 数据库
数据库三范式
- 1范式：列的原子性，不可再分
- 2范式：列依赖于主键，而不是依赖与主键的一部分
- 3范式：不存在列对主键的传递依赖  
数据冗余少，更新维护简单。

### Mysql
- ACID特性
- 方便进行聚合范围查找，聚合、统计等操作
- 当数据规模变大时，查找性能变低

where 和 having，having是对分组后的数据进行条件筛选  
等值连接  
子查询，查询基于未知，子查询必须包含在括号内  
单行子查询 单行运算符；多行子查询 多行运算符。  
事务savepoint  
where查询条件，运算顺序从右到左，把快速缩小查询范围的条件放在右侧  

**存储**： 磁盘，B+树，支持索引查找，磁盘块读出

操作时间因素：**时间复杂度** + **数据规模**

当单表数据量很大时，查询性能很低  (减小表规模、将请求分发到多台服务器上 )
- 将历史数据归档到备份表
- 集群：主从复制，利用从数据库进行读写分离
- 缓存：缓存部分联表查询结果等
- 分库分表：减小数据规模

提高运算能力，集群，保持数据一致性，负载均衡

### Redis:
- 基于内存的k-v数据库，数据结构，读写性能高
- 内存容量有限，对事务的支持差，不用于持久层

将mysql的数据**子集**缓存在redis中

缓存的命中率

1. cache aside: 旁路缓存模式
- 读
缓存中有值，直接返回
缓存中无值，从数据库取值，更新缓存，返回
- 写
更新数据库，删除缓存
2. read write through
3. write behind

#### redis mysql 数据一致性：不考虑进程执行中断
- 先更新缓存，再更新数据库
a更新缓存，b更新缓存 ---> b更新数据库，a更新数据库
- 先更新数据库，再更新缓存
a更新数据库，b更新数据库   --->  b更新缓存，a更新缓存
- 先删除缓存，再更新数据库
a删除缓存 -> b读数据库更新缓存 -> a更新数据库
- 先更新数据库，再删除缓存
b查找数据库，a更新数据库 ---> a删除缓存，b用旧值更新缓存 (这种发生概率比较低，因为更新数据库一般比查找耗时长，所以a删除缓存在后)。
问题: a 更新数据库，到删除缓存这段时间，b读到旧的缓存值(短暂不一致)
- 延时双删

不能保证两个操作同时成功或失败。
上述实践中大都可以保证相对一致性，若保证绝对一致性，要依靠事务保证操作更新同时成功或失败，出现问题则回滚，但**这与使用缓存提高性能的初衷相违背**，得不偿失。

replication 备份
sharding 分片


