## gcc
查看gcc版本
```
gcc -v
```

### gcc工作流程
gcc编译器对程序的编译，分为4个阶段：预处理（预编译）、编译和优化、汇编、和链接。
1. 预处理。在这个阶段主要做了3件事：展开头文件、宏替换、去掉注释行。这个阶段需要GCC调用预处理器来完成，最终得到的还是源文件，文本格式。
2. 编译：这个阶段需要gcc调用编译器cc1（C 前端） 对文件进行编译，最终得到一个汇编文件。
3. 汇编：这个阶段需要gcc调用汇编器as对文件进行汇编，最终得到一个二进制文件。
4. 链接：这个阶段需要gcc调用链接器ld对程序要调用的库进行链接，最终得到一个可执行的二进制文件。

| 文件名后缀| 说明 | gcc参数 |
| --- | --- | --- |
| .c|源文件 | |
| .i | 预处理后的c文件 |-E |
| .s | 编译之后汇编语言的源文件 |-s |
| .o| 汇编后得到的二进制文件 |-c |

| gcc编译选项 | 含义|
| --- | --- |
| -o | 指定生成文件的名字|
| -I | include包含头文件的搜索路径 |
| -g | 在编译的时候，生成调试信息，该程序可以被调试器调试|
| -D | 程序编译的时候指定一个宏|
| -Wall | 生成所有警告信息 |
| -l | 在程序编译的时候，指定使用的库名字，如 -l stdc++ |
| -L| 编译的时候，搜索的库路径 |
| -fipc | 生成的代码与位置无关，使用的是相对地址 |
| -shared| 生成共享库文件 |

### gcc与g++
1. 在代码编译阶段
后缀为.c的，gcc会把当当作C程序，而g++会当作是C++程序  
后缀为.cpp的，两者都会认为是C++程序。C++的语法规则会更加严谨一些  
g++会调用gcc，对于C++代码，两者是等价的。也就是gcc和g++都可以编译C/C++程序  
2. 在链接阶段
gcc和g++都可以自动链接到标准C库  
g++可以自动链接到标准C++库，gcc如果要链接到标准C++库需要加参数-lstd++  
3. 关于_cplusplus宏的定义
g++会自动定义_cplusplus宏，但是不影响它去编译C程序  
gcc需要根据文件后缀判断是否需要定义_cplusplus宏（规则参考第一条）  

## 静态库 动态库
作用：使程序更加简洁，不需要在项目中维护太多的源文件，同时源代码保密  
使用：发布库文件（动态库、静态库），和库中提供的API函数的声明，也就是头文件。
### 命名
1. 静态库  
库中函数和变量的地址使用的是绝对地址  
- 在Linux中静态库以lib作为前缀，以.a作为后缀  
- 在windows中静态库以lib作为前缀，以lib作为后缀 
2. 动态库  
库中函数和变量的地址使用的是相对地址  
- 在Linux中动态库以lib作为前缀，以.so作为后缀  
- 在windows中动态库以lib作为前缀，以dll作为后缀
- 在macOS平台动态库以lib作为前缀，以dylib作为后缀
### 如何被加载
1. 静态库  
- 在程序编译的最后一个阶段也就是链接阶段，提供的静态库会被打包到可执行程序中。
- 当可执行程序被执行时，静态库中的代码也会一并被加载到内存中，因此不会出现静态库找不到无法加载的问题。  
2. 动态库    
- 在程序编译的最后一个阶段也就是链接阶段，
gcc命令虽然指定了库路径（使用参数-L）,但是这个路径并没有被记录到可执行程序中，只是检查了这个路径下的库文件是否存在。  
- 同样对应的动态库文件也没有被打包到可执行程序中，只是在可执行程序中记录了库的名字。  
- 可执行程序执行起来之后  
程序执行的时候会先检测需要的动态库是否可以加载，加载不到会提示错误信息。  
**当动态库中的函数在程序中被调用了**，这个时候动态库才加载到内存中，如果不被调用就不加载  
动态库的检测和内存加载操作是**动态链接器**来完成的。
LD_LIBRARY_PATH环境变量  
ldd 检测即将执行的可执行程序能否加载需要的动态库  

### 比较
1. 静态库
- 优点  
静态库被打包到内存中加载速度快  
发布程序无需提供静态库，移植方便  
- 缺点  
相同的库文件数据可能在内存中被加载多份，消耗系统资源，浪费内存。  
库文件更新需要重新编译项目文件，生成新的可执行程序、浪费时间。
2. 动态库
- 优点  
可实现**不同进程**间的资源共享  
动态库升级简单，只需要更新替换库文件，无需重新编译应用程序  
程序员可以控制何时加载动态库，不调用库函数动态库不会被加载  
- 缺点  
加载速度比静态库慢  
发布程序需要提供依赖的动态库   

```
gcc *.cpp -l * -L *
```

## CMakeLists.txt
```
cmake根据 cmakelist.txt生成makefile，make对makefile生成库或可执行文件。

cmake_minimum_required 指定cmake的最低版本

project 项目工程名

定义变量，默认为字符串类型
set(变量名 值)

搜索文件
aux_source_directory(路径 变量名)
file(GLOB|  变量名 路径)

add_subdirectory()添加子目录

include包含头文件的搜索路径 
include_directories()

set(EXECUTABLE_OUTPUT_PATH )指定可执行程序输出的路径  
set(LIBRARAY_OUTPUT_PATH )指定生成库文件输出的路径  

link_directories() 自定义的库文件需要指定查找路径
link_libraries()链接库文件

add_executable(程序名 源文件名) 生成可执行程序，源文件名空格或分号分割
add_library(静态库名 STATIC 源文件名) 生成静态库  
add_library(动态库名 SHARED 源文件名) 生成动态库  

target_link_libraries(target PUBLIC|PRIVATE|INTERFACE 链接库文件)  
动态库链接有传递性，PUBLIC一直传递，PRIVATE只能传递一次。默认PUBLIC链接  
```
