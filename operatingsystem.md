
避免死锁：银行家算法

## 文件系统：
- 连续存储 链式存储
- 索引

日志文件系统

### io 模型:
**同步**
1. 阻塞  等待从磁盘->page cache, page cache->内存 1线程对应1 io
2. 非阻塞 轮询page cache 中数据是否准备好，没有则直接返回。page cache -> 内存仍然是阻塞的
3. io多路复用：1个线程轮询多个socket的情况，支持更高的并发
- select, poll:
将多个文件描述符从用户空间传入内核空间
内核轮询列表看是否有socket就绪，有则设置标记状态
将fd列表从内核空间传入用户空间，
用户遍历列表对可读可写的socket的读写数据处理
差别: select用数组存储，poll用链表存储没有fd数量的限制
- epoll:
由内核维护fd列表，红黑树，调用`epoll_ctl`添加删除fd
epoll_wait 时，当有socket 可读可写时，通过回调添加到就绪链表，返回给用户空间
边缘触发|水平触发：当socket就绪，用户不做处理，第二次不通知（边缘触发），所以一般配合非阻塞io处理，减少系统调用次数

**异步**：异步是一种编程模型，它通过将耗时的操作转移到后台线程运行，从而减少对主业务的堵塞，所以我们说异步让速度变快了


## tcp
流量控制

### 拥塞控制
最大报文段 SMSS(sender Maximum Segment Size),  慢开始门限(ssthresh)
当cwnd < ssthresh 收到接收方确认后，cwnd指数增长
**拥塞避免**：cwmd > ssthresh 收到接收方确认后，cwnd 线性增长。
慢开始：超时未收到确认，判断 网络出现拥塞，ssthresh = cwmd / 2, cwnd = 1,执行慢开始
**快重传**：连续收到3个重复确认，立即重传。
只是个别报文段的丢失，快恢复，ssthresh = cwnd / 2, cwmd /= 2, 执行拥塞避免算法 **快恢复**
