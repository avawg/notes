## Java
Java类型提升，byte short char自动提升为int
```java
char c = 0; byte b = 0;
c = c + b;
```
运行是错误的。

**泛型**  
将类型参数化，编译时会进行类型检查。实现代码重用，以及可阅读性。  

泛型作用在方法和接口  
泛型方法，限制方法的参数类型和返回类型。  

## 进程线程
**进程**
想要使程序并发执行，存在间断性，失去封闭性，不可再现等问题，引入进程。
动态执行的应用程序，不仅有代码段，还有内存和文件io等运行资源。运行态、就绪态、阻塞态，线程间状态切换会自动保存上下文，使进程并发执行，进程间引入同步机制。执行副本，资源分配的最小单位。

使用场景: cpu密集型运算， 涉及到很多io阻塞等待

**线程**
代码执行线，线程被cpu调度并发执行，cpu运行调度的基本单元。共享进程的运行资源，虚拟内存，文件列表等，线程间通信很方便。

**协程**
同样有执行上下文的保存和恢复，用户程序通过函数调用的形式进行执行线的切换，不涉及执行上下文的切换。

### 线程安全
加锁的成本开销有多大，业务场景中访问的共享资源的方式，并发访问共享资源时的冲突概率。

1. 互斥访问（互斥锁）：互斥锁（队列排队等待），自旋锁（轮询尝试获取锁）
- 互斥锁的代价：线程状态上下文切换 运行态-> 阻塞态，阻塞态-> 就绪态
- 自旋锁上锁代价：占有锁线程的运行时间

2. 乐观锁(无锁)：假设竞争不激烈，不断重试

降低锁竞争：
- 设计成不可变类，threadlocal多份变量
- 减小锁粒度，减少锁持有时间
- 读写锁分离

**线程池**  
- 控制线程的数量。线程太多: 内存占用，时间花在上下文切换，吞吐率低。
- 预先创建线程，加快线程的响应速度。  

**线程池的线程数量设置**  
- cpu密集型  
- io密集型
`threadlocal<ClassType>` 每个线程`t`有一个`threadLocalMap`
`key=threadlocal weak reference`，`value`用完要`remove`否则会发生内存泄漏

### Java 内存模型：
定义了不同的线程之间，通过哪些方式，在什么时候可以看见其他线程保存到共享变量中的值；以及在必要时，如何对共享变量的访问进行同步。这样的好处是屏蔽各种硬件平台和操作系统之间的内存访问差异，实现了 Java 并发程序真正的跨平台。定义程序中各种变量的访问规则。

java虚拟机：模拟正式的物理机   
java内存结构  
- 栈：  
- 堆: 存放申请的对象  
- 方法区：类信息，静态变量，常量池。实现有元空间，永久代。类信息包括了类的版本、字段、方法、接口和父类等信息。  

垃圾回收主要在堆内存区域  
垃圾的判别：引用计数 可达性分析  

gc算法：
- mark-sweep 标记清除  
- mark-copy 复制  
- mark-compact 标记整理  
- 分代垃圾回收算法，根据对象生命周期的不同分为年轻代和老年代  

垃圾收集器：
- Serial 串行垃圾回收器   
- Parallel 并行垃圾回收器 主线程和gc线程并行运行  
- Parnew  
- CMS concurrent mark sweep 并发标记清除  

一些参数设置  
-Xms初始堆大小，-Xmx最大堆大小  
-XX:MetaspaceSize初始元空间大小，-XX:MaxMetaspaceSize最大元空间大小  

### spring容器
classpathxmlApplicationContext 容器
构造方法
管理哪些对象
如何将管理的对象告知Ioc容器
如何获取Ioc容器
如何从容器中获取bean

### servlet生命流程
servlet 有servlet容器创建，第一次被访问时，由容器创建
初始化
请求处理
服务终止

### zookeeper
ZooKeeper 底层其实只提供了两个功能：1.管理（存储、读取）用户程序提交的数据；2.为用户程序提供数据节点监听服务

## 系统
高可用
高性能： 响应时间，吞吐量、并发量
可伸缩
高可扩展

## 消息队列
消息队列延迟时间
低延迟、高可靠。高吞吐

java NIO 面向缓冲区，不再面向字节流

多路复用 配合阻塞io不可以吗？

mvn 初始化.m2仓库  

项目坐标  
```xml
<groupId> </groupId>
<artifactId> </artifactId>
<version> </version>
```